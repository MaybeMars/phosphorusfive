<!DOCTYPE html>
<html>
<head>
<title>Phosphorus.Five - Enabling Agile Development - Package expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<div id="titlearea">
  <a class="logo" title="Phosphorus.Five project main website" href="http://magixilluminate.com">
  <img alt="Magix Illuminate" src="magix-logo-big.png"/>
  </a>
  <h1 id="projectname">Phosphorus.Five</h1>
  <p id="projectbrief">Enabling Agile Development</p>
  <a id="download-tar" title="download tarball" href="https://github.com/polterguy/phosphorus-five/tarball/master">&nbsp;</a>
  <a id="download-zip" title="downlad zipball" href="https://github.com/polterguy/phosphorus-five/zipball/master">&nbsp;</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Package expressions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a06d6095b04acc5f818cff12092629720"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceexpressions.html#a06d6095b04acc5f818cff12092629720">[instance initializer]</a></td></tr>
<tr class="separator:a06d6095b04acc5f818cff12092629720"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the Expression engine in Phosphorus.Five. Main namespace for the Expression engine in Phosphorus.Five.</p>
<pre class="fragment">This namespace contains the Expression engine for Phosphorus.Five, and is what allows you to compose
This namespace contains the Expression engine for Phosphorus.Five, and is what allows you to compose
expressions, extracting node result-set from your pf.lambda execution tree.
expressions, extracting node result-set from your pf.lambda execution tree.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a06d6095b04acc5f818cff12092629720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">expressions.[instance initializer] </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main expression class in Phosphorus.Five. The main expression class in Phosphorus.Five.</p>
<pre class="fragment">Responsible for parsing, building and evaluating your pf.lambda expressions, according to what types of iterators
Responsible for parsing, building and evaluating your pf.lambda expressions, according to what types of iterators
you compose together to form your complete expression.
you compose together to form your complete expression.


An expression is normally recognized automatically by any Active Events that supports them, and starts with a "@" character,
An expression is normally recognized automatically by any Active Events that supports them, and starts with a "@" character,
followed by any number of Iterator objects, ending with a type declaration.
followed by any number of Iterator objects, ending with a type declaration.


Example;
Example;


&lt;pre&gt;@/../*?node&lt;/pre&gt;
&lt;pre&gt;@/../*?node&lt;/pre&gt;


The above example will find all children nodes of the root node of your current execution tree.
The above example will find all children nodes of the root node of your current execution tree.


There are 5 different types of expressions you can declare;
There are 5 different types of expressions you can declare;


1. &lt;strong&gt;?value&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Value"&gt;value&lt;/see&gt; property of your nodes.
1. &lt;strong&gt;?value&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Value"&gt;value&lt;/see&gt; property of your nodes.
2. &lt;strong&gt;?name&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Name"&gt;name&lt;/see&gt; property of your nodes.
2. &lt;strong&gt;?name&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Name"&gt;name&lt;/see&gt; property of your nodes.
3. &lt;strong&gt;?count&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Count"&gt;count&lt;/see&gt; property of your nodes.
3. &lt;strong&gt;?count&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Count"&gt;count&lt;/see&gt; property of your nodes.
4. &lt;strong&gt;?path&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Path"&gt;path&lt;/see&gt; property of your nodes.
4. &lt;strong&gt;?path&lt;/strong&gt; - Returns the &lt;see cref="phosphorus.core.Node.Path"&gt;path&lt;/see&gt; property of your nodes.
5. &lt;strong&gt;?node&lt;/strong&gt; - Returns the actual &lt;see cref="phosphorus.core.Node"&gt;nodes&lt;/see&gt; themselves.
5. &lt;strong&gt;?node&lt;/strong&gt; - Returns the actual &lt;see cref="phosphorus.core.Node"&gt;nodes&lt;/see&gt; themselves.


Both '?count' and '?path' types of expressions are "read-only", and cannot be used as destinations, or changed in any
Both '?count' and '?path' types of expressions are "read-only", and cannot be used as destinations, or changed in any
ways. All other types of expressions, can be both assigned to, and retrieved.
ways. All other types of expressions, can be both assigned to, and retrieved.


PS!&lt;br/&gt;
PS!&lt;br/&gt;
Normally you don't want to consume this class directly, but instead use it indirectly through the XUtil class,
Normally you don't want to consume this class directly, but instead use it indirectly through the XUtil class,
which contains many helper methods to create and evaluate expressions for you!
which contains many helper methods to create and evaluate expressions for you!
</pre> <p>Initializes a new instance of the phosphorus.expressions.Expression class. Initializes a new instance of the phosphorus.expressions.Expression class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>to evaluate</td></tr>
    <tr><td class="paramname">expression</td><td>to evaluate</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluates expression for given <a class="el" href="">node</a>. Evaluates expression for given <a class="el" href="">node</a>.</p>
<pre class="fragment">Returns a match object wrapping the result from your Expression.
Returns a match object wrapping the result from your Expression.


PS!
PS!
Normally you very seldom want to use this method directly, or this class for that matter, but instead
Normally you very seldom want to use this method directly, or this class for that matter, but instead
use one of the helper methods in the XUtil class, which takes care of creating expressions, and evaluating
use one of the helper methods in the XUtil class, which takes care of creating expressions, and evaluating
then automatically for you.
then automatically for you.
</pre> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>cleanup, too long ... </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>cleanup, too long ... </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>shares a lot of functionality with XUtil.ExpressionType, try to refactor </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>shares a lot of functionality with XUtil.ExpressionType, try to refactor </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>support formatting expressions through delegate callbacks, such that XUtil.Iterate </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>support formatting expressions through delegate callbacks, such that XUtil.Iterate </dd></dl>
<p>Class encapsulating Boolean algebraic operations for the Expression class. Class encapsulating Boolean algebraic operations for the Expression class.</p>
<pre class="fragment">Logicals are what allows you to perform Boolean Algebra on your expressions, and are normally defined in your 
Logicals are what allows you to perform Boolean Algebra on your expressions, and are normally defined in your 
expressions using either of these characters; &amp;, |, ^ or !
expressions using either of these characters; &amp;, |, ^ or !


! is your NOT operator, and means that it should NOT return whatever is returned as a result of your right-hand-side sub-expression.
! is your NOT operator, and means that it should NOT return whatever is returned as a result of your right-hand-side sub-expression.


| is your OR operator, and signifies that your expression should add together the results of your right-hand-side expression, 
| is your OR operator, and signifies that your expression should add together the results of your right-hand-side expression, 
with whatever is at your left-hand-side as a combined result.
with whatever is at your left-hand-side as a combined result.


&amp; is your AND operator, and basically means that in order to be a part of the combined results, the nodes must match both the 
&amp; is your AND operator, and basically means that in order to be a part of the combined results, the nodes must match both the 
left-hand-side, and the right-hand-side sub-expression.
left-hand-side, and the right-hand-side sub-expression.


^ is your XOR operator, and basically means that it should combine together the results of both your left-hand-side, with your
^ is your XOR operator, and basically means that it should combine together the results of both your left-hand-side, with your
right-hand-side, but only if it matches only ONE of your sides, and not if it matches neither sides or both sides.
right-hand-side, but only if it matches only ONE of your sides, and not if it matches neither sides or both sides.


Example of an Expression returning all children nodes of the root node, having a value of "foo", but excluding the ones
Example of an Expression returning all children nodes of the root node, having a value of "foo", but excluding the ones
whos name is "bar";
whos name is "bar";


&lt;pre&gt;@/../*(/=foo!/bar)?node&lt;/pre&gt;
&lt;pre&gt;@/../*(/=foo!/bar)?node&lt;/pre&gt;
</pre> <p>Type of boolean operator. Type of boolean operator.</p>
<pre class="fragment">This is the type declaration of your Logical, and can be either !, &amp;, | or ^, declaring which Boolean operator
This is the type declaration of your Logical, and can be either !, &amp;, | or ^, declaring which Boolean operator
and operation you wish to perform on your expressions and sub-expressions.
and operation you wish to perform on your expressions and sub-expressions.
</pre> <p>OR operator, for ORing results together. OR operator, for ORing results together.</p>
<pre class="fragment">Defined through the pipe character (|).
Defined through the pipe character (|).
</pre> <p>AND operator, for ANDing results together. AND operator, for ANDing results together.</p>
<pre class="fragment">Defined through the ampersand character (&amp;).
Defined through the ampersand character (&amp;).
</pre> <p>XOR operator, for XORing results together. XOR operator, for XORing results together.</p>
<pre class="fragment">Defined through the hat character (^).
Defined through the hat character (^).
</pre> <p>NOT operator, for NOTing results together. NOT operator, for NOTing results together.</p>
<pre class="fragment">Defined through the exclamation mark character (!).
Defined through the exclamation mark character (!).
</pre> <p>Initializes a new instance of the phosphorus.expressions.Logical class. Initializes a new instance of the phosphorus.expressions.Logical class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of logical, Or, And, Xor or Not.</td></tr>
    <tr><td class="paramname">type</td><td>Type of logical, Or, And, Xor or Not.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the last phosphorus.expressions.iterators.Iterator in the list of iterators belonging to Returns the last phosphorus.expressions.iterators.Iterator in the list of iterators belonging to this logical. this logical. </p>
<p>The last iterator in the chain of iterators.</p>
<p>The last iterator in the chain of iterators.</p>
<p>Gets the type of logical. Gets the type of logical.</p>
<pre class="fragment">Can be either Or, And, Xor or Not.
Can be either Or, And, Xor or Not.
</pre> <p>The type of logical.</p>
<p>The type of logical.</p>
<p>Adds an iterator to the current logical group. Adds an iterator to the current logical group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Tterator to append to chain of iterators.</td></tr>
    <tr><td class="paramname">iterator</td><td>Tterator to append to chain of iterators.</td></tr>
  </table>
  </dd>
</dl>
<p>Expression result class. Expression result class.</p>
<pre class="fragment">When you evaluate a pf.lambda expression, then this is the result you end up with as your result.
When you evaluate a pf.lambda expression, then this is the result you end up with as your result.


PS!&lt;br/&gt;
PS!&lt;br/&gt;
Normally you don't want to use this class directly yourself, but rather use one of the helper methods from
Normally you don't want to use this class directly yourself, but rather use one of the helper methods from
XUtil, that abstracts away this class, in addition to the Expression class itself.
XUtil, that abstracts away this class, in addition to the Expression class itself.
</pre> <p>Type of match for your match object. Type of match for your match object.</p>
<pre class="fragment">Can be either 'name', 'value', 'count', 'path' or 'node'. This is the part that you define when you create 
Can be either 'name', 'value', 'count', 'path' or 'node'. This is the part that you define when you create 
your type declaration within your pf.lambda Expression. For instance '?name', creates a 'name' type of Expression.
your type declaration within your pf.lambda Expression. For instance '?name', creates a 'name' type of Expression.
</pre> <p>Returns <a class="el" href="">name</a> property of matched nodes. Returns <a class="el" href="">name</a> property of matched nodes.</p>
<pre class="fragment">Declared through the type declaration of '?name'.
Declared through the type declaration of '?name'.
</pre> <p>Returns <a class="el" href="">value</a> property of matched nodes. Returns <a class="el" href="">value</a> property of matched nodes.</p>
<pre class="fragment">Declared through the type declaration of '?value'.
Declared through the type declaration of '?value'.
</pre> <p>Returns <a class="el" href="">count</a> property of matched nodes. Returns <a class="el" href="">count</a> property of matched nodes.</p>
<pre class="fragment">Declared through the type declaration of '?count'.
Declared through the type declaration of '?count'.
</pre> <p>Returns <a class="el" href="">count</a> property of matched nodes. Returns <a class="el" href="">count</a> property of matched nodes.</p>
<pre class="fragment">Declared through the type declaration of '?path'.
Declared through the type declaration of '?path'.
</pre> <p>Returns <a class="el" href="">count</a> themselves. Returns <a class="el" href="">count</a> themselves.</p>
<pre class="fragment">Declared through the type declaration of '?node'.
Declared through the type declaration of '?node'.
</pre> <p>Returns number of nodes in match. Returns number of nodes in match.</p>
<pre class="fragment">This value is the number of nodes you have in your result-set, after evaluating your Expression.
This value is the number of nodes you have in your result-set, after evaluating your Expression.
</pre> <p>Number of nodes in match.</p>
<p>Number of nodes in match.</p>
<p>Gets the type of match. Gets the type of match.</p>
<pre class="fragment">The type declaration of your match.
The type declaration of your match.
</pre> <p>The type declaration of your Expression.</p>
<p>The type declaration of your Expression.</p>
<p>Type to convert values retrieved from match to. Type to convert values retrieved from match to.</p>
<pre class="fragment">Optionally, you can create a type-conversion of your result-set, such that the returned result-set values
Optionally, you can create a type-conversion of your result-set, such that the returned result-set values
in your Expression, after evaluation, becomes converted to any of the types your project supports through your
in your Expression, after evaluation, becomes converted to any of the types your project supports through your
existing [pf.hyperlisp.get-object-value.xxx] Active Events.
existing [pf.hyperlisp.get-object-value.xxx] Active Events.


Unless you explicitly tells the expression engine that you wish to convert your Expression's result-set, then
Unless you explicitly tells the expression engine that you wish to convert your Expression's result-set, then
no conversion will occur, and the values of your evaluated expression will be returned "as is".
no conversion will occur, and the values of your evaluated expression will be returned "as is".
</pre> <p>Type to convert to, can be any of your Hyperlisp types, defined through your [pf.hyperlisp.get-type-name.xxx] </p>
<p>Type to convert to, can be any of your Hyperlisp types, defined through your [pf.hyperlisp.get-type-name.xxx] Active Events.</p>
<p>Active Events.</p>
<p>Returns the MatchEntity at the index position. Returns the MatchEntity at the index position.</p>
<pre class="fragment">Returns the n'th matched entity.
Returns the n'th matched entity.


PS!&lt;br/&gt;
PS!&lt;br/&gt;
The match class implements IEnumerable, which allows you to iterate over all results, which means you'll very rarely,
The match class implements IEnumerable, which allows you to iterate over all results, which means you'll very rarely,
if ever, need to fiddle with this method yourself.
if ever, need to fiddle with this method yourself.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Which position you wish to retrieve.</td></tr>
    <tr><td class="paramname">index</td><td>Which position you wish to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the enumerator for MatchEntity objects. Gets the enumerator for MatchEntity objects.</p>
<pre class="fragment">Returns the IEnumerator for all MatchEntity objects within your match.
Returns the IEnumerator for all MatchEntity objects within your match.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">the enumerator</p>
<p class="enddd">the enumerator</p>
</dd></dl>
<p>Wraps a single match. Wraps a single match.</p>
<pre class="fragment">When an Expression is evaluated, and returned as a Match object, then this class encapsulates one single
When an Expression is evaluated, and returned as a Match object, then this class encapsulates one single
matched item (node, value, path, name or count) from your Expression.
matched item (node, value, path, name or count) from your Expression.
</pre> <p>Node that was matched. Node that was matched.</p>
<pre class="fragment">This is not necessarily the Value of your match entity object.
This is not necessarily the Value of your match entity object.
</pre> <p>Node for match entity item.</p>
<p>Node for match entity item.</p>
<p>Type of match. Type of match.</p>
<pre class="fragment">Sometimes, especially when you're using reference expressions, then the type of match you end up with, is
Sometimes, especially when you're using reference expressions, then the type of match you end up with, is
a mixed type. Meaning, some of your match entity items will be of type 'node', while others might be of type 'value',
a mixed type. Meaning, some of your match entity items will be of type 'node', while others might be of type 'value',
and so on. If so is the case, then this property will return the type declaration of your match entity item, instead
and so on. If so is the case, then this property will return the type declaration of your match entity item, instead
of the type declaration of your Expression as a whole.
of the type declaration of your Expression as a whole.
</pre> <p>Type of match for match entity item.</p>
<p>Type of match for match entity item.</p>
<p>Returns the parent match instance. Returns the parent match instance. </p>
<p>Parent match.</p>
<p>Parent match.</p>
<p>Retrieves or sets the value for the match entity item. Retrieves or sets the value for the match entity item.</p>
<pre class="fragment">Use this property to retrieve the actual value of your expression's matched entity items.
Use this property to retrieve the actual value of your expression's matched entity items.
If you assign a &lt;see cref="phosphorus.core.Node"&gt;Node&lt;/see&gt; to another node, then the node will
If you assign a &lt;see cref="phosphorus.core.Node"&gt;Node&lt;/see&gt; to another node, then the node will
be cloned before assignment, to avoid UnTying node from existing parent node's children collection.
be cloned before assignment, to avoid UnTying node from existing parent node's children collection.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">The value of the match entity item.</p>
<p class="enddd">The value of the match entity item.</p>
</dd></dl>
<p>Tokenizer for the Expression class. Tokenizer for the Expression class.</p>
<pre class="fragment">Responsible for tokenizing expressions, by breaking them up into tokens. Not something you'd normally fiddle
Responsible for tokenizing expressions, by breaking them up into tokens. Not something you'd normally fiddle
with yourself.
with yourself.
</pre> <p>Initializes a new instance of the phosphorus.expressions.Tokenizer class. Initializes a new instance of the phosphorus.expressions.Tokenizer class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression to tokenize.</td></tr>
    <tr><td class="paramname">expression</td><td>Expression to tokenize.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all tokens in expression. Returns all tokens in expression.</p>
<pre class="fragment">Iterates through all tokens in your Expression.
Iterates through all tokens in your Expression.
</pre> <p>The tokens consisting your Expression.</p>
<p>The tokens consisting your Expression.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>refactor, too complex </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>refactor, too complex </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>Cleanup all of these comments, in addition to rethinking the name of the "dataSource" parameters, since they're highly unintuitive for the moment </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Cleanup all of these comments, in addition to rethinking the name of the "dataSource" parameters, since they're highly unintuitive for the moment </dd></dl>
<p>Helper class for handling pf.lambda Expression objects. Helper class for handling pf.lambda Expression objects.</p>
<pre class="fragment">This is the class you'd normally use when consuming expressions. Contains many useful helper methods for
This is the class you'd normally use when consuming expressions. Contains many useful helper methods for
iterating expression result-sets, retrieve single compund values from expressions, etc.
iterating expression result-sets, retrieve single compund values from expressions, etc.
</pre> <p>Returns true if value is an Expression. Returns true if value is an Expression.</p>
<pre class="fragment">If given value is an Expression, then this method will return true.
If given value is an Expression, then this method will return true.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd"><code>true</code> if value is an Expression; otherwise, <code>false</code>.</p>
<p class="enddd"><code>true</code> if value is an Expression; otherwise, <code>false</code>.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to check.</td></tr>
    <tr><td class="paramname">value</td><td>Value to check.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if value is an Expression. Returns true if value is an Expression.</p>
<pre class="fragment">If given value is an Expression, then this method will return true.
If given value is an Expression, then this method will return true.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd"><code>true</code> if value is an Expression; otherwise, <code>false</code>.</p>
<p class="enddd"><code>true</code> if value is an Expression; otherwise, <code>false</code>.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>String value to check.</td></tr>
    <tr><td class="paramname">value</td><td>String value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>simplify, needs support for expressions on multiple lines, having first iterator on second line </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>simplify, needs support for expressions on multiple lines, having first iterator on second line </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>refactor, too complex, also contains overlapping functionality with Expression.cs </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>refactor, too complex, also contains overlapping functionality with Expression.cs </dd></dl>
<p>Returns type of Expression. Returns type of Expression.</p>
<pre class="fragment">Will parse and figure out what type of Expression we're dealing with, and return that to caller.
Will parse and figure out what type of Expression we're dealing with, and return that to caller.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">Type of Expression.</p>
<p class="enddd">Type of Expression.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expressionNode</td><td>Node containing expression to check, will be formatted if necessary.</td></tr>
    <tr><td class="paramname">expressionNode</td><td>Node containing expression to check, will be formatted if necessary.</td></tr>
    <tr><td class="paramname">context</td><td>Application context. Necessary to perform conversions.</td></tr>
    <tr><td class="paramname">context</td><td>Application context. Necessary to perform conversions.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true if given node's value is formatted. Returns true if given node's value is formatted.</p>
<pre class="fragment">A formatted value of a &lt;see cref="phosphorus.code.Node"&gt;Node&lt;/see&gt;, means that the node has at least one 
A formatted value of a &lt;see cref="phosphorus.code.Node"&gt;Node&lt;/see&gt;, means that the node has at least one 
child node, with an empty name. If it does, then the node is assumed to be "formatted", meaning its value 
child node, with an empty name. If it does, then the node is assumed to be "formatted", meaning its value 
should not be interpreted in isolation, but be formatted according to the values of all children nodes, who's
should not be interpreted in isolation, but be formatted according to the values of all children nodes, who's
names are string,Empty (""), using similar type of logic as can be found in for instance string.Format from C#.
names are string,Empty (""), using similar type of logic as can be found in for instance string.Format from C#.


An example of a formatted node;
An example of a formatted node;


&lt;pre&gt;
&lt;pre&gt;
</pre><p> foo:bar {0} foo:bar {0} :some-value :some-value </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd"><code>true</code> if node contains formatting parameters; otherwise, <code>false</code>.</p>
<p class="enddd"><code>true</code> if node contains formatting parameters; otherwise, <code>false</code>.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to check.</td></tr>
    <tr><td class="paramname">node</td><td>Node to check.</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the given node, and returns the formatted value. Formats the given node, and returns the formatted value.</p>
<pre class="fragment">Basically enumerates all children nodes of given node, and uses all child node with an empty name as
Basically enumerates all children nodes of given node, and uses all child node with an empty name as
a formatting parameter, which combined yields the "true" value of the node.
a formatting parameter, which combined yields the "true" value of the node.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">Formatted string value.</p>
<p class="enddd">Formatted string value.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node containing formatting expression, and formatting children nodes.</td></tr>
    <tr><td class="paramname">node</td><td>Node containing formatting expression, and formatting children nodes.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the given node, and returns the formatted value. Formats the given node, and returns the formatted value.</p>
<pre class="fragment">Basically enumerates all children nodes of given node, and uses all child node with an empty name as
Basically enumerates all children nodes of given node, and uses all child node with an empty name as
a formatting parameter, which combined yields the "true" value of the node.
a formatting parameter, which combined yields the "true" value of the node.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">Formatted string value.</p>
<p class="enddd">Formatted string value.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node containing formatting expression, and formatting children nodes.</td></tr>
    <tr><td class="paramname">node</td><td>Node containing formatting expression, and formatting children nodes.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data-source for any expressions within formatting parameters.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data-source for any expressions within formatting parameters.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Tries to format the given node's value. Tries to format the given node's value.</p>
<pre class="fragment">If node is formatted, will format the given node, and return the formatted value of the node.
If node is formatted, will format the given node, and return the formatted value of the node.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">The value of the node after formatting, possibly converted.</p>
<p class="enddd">The value of the node after formatting, possibly converted.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node that might be formatted.</td></tr>
    <tr><td class="paramname">node</td><td>Node that might be formatted.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return, if node has no value at all.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return, if node has no value at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type you wish to convert the node's value into.</td></tr>
    <tr><td class="paramname">T</td><td>The type you wish to convert the node's value into.</td></tr>
  </table>
  </dd>
</dl>
<p>Tries to format the given node's value. Tries to format the given node's value.</p>
<pre class="fragment">If node is formatted, will format the given node, and return the formatted value of the node.
If node is formatted, will format the given node, and return the formatted value of the node.
</pre> <dl class="section return"><dt>Returns</dt><dd><p class="startdd">The value of the node after formatting, possibly converted.</p>
<p class="enddd">The value of the node after formatting, possibly converted.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node that might be formatted.</td></tr>
    <tr><td class="paramname">node</td><td>Node that might be formatted.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Data source to use for formatting operation, if formatting parameters contains expressions.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Data source to use for formatting operation, if formatting parameters contains expressions.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return, if node has no value at all.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return, if node has no value at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type you wish to convert the node's value into.</td></tr>
    <tr><td class="paramname">T</td><td>The type you wish to convert the node's value into.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a single value of type T from the constant or expression in node's value. Returns a single value of type T from the constant or expression in node's value.</p>
<pre class="fragment">If node's value is an expression, then expression will be evaluated, and result of expression converted to T. 
If node's value is an expression, then expression will be evaluated, and result of expression converted to T. 
If expression yields multiple results, then the results will be concatenated into a string, in order
If expression yields multiple results, then the results will be concatenated into a string, in order
evaluated, before string is converted to T and returned.
evaluated, before string is converted to T and returned.


If expression returns one result, or node's value is a constant, then no conversion will be performed, 
If expression returns one result, or node's value is a constant, then no conversion will be performed, 
unless necessary due to different types in expression's result or constant.
unless necessary due to different types in expression's result or constant.


If node contains formatting children, these will be evaluated as a formatting expression, before Expression 
If node contains formatting children, these will be evaluated as a formatting expression, before Expression 
is created, or constant is returned.
is created, or constant is returned.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a single value of type T from the constant or expression in node's value. Returns a single value of type T from the constant or expression in node's value.</p>
<pre class="fragment">If node's value is an expression, then expression will be evaluated, and result of expression converted to T. 
If node's value is an expression, then expression will be evaluated, and result of expression converted to T. 
If expression yields multiple results, then the results will be concatenated into a string, in order
If expression yields multiple results, then the results will be concatenated into a string, in order
evaluated, before string is converted to T and returned.
evaluated, before string is converted to T and returned.


If expression returns one result, or node's value is a constant, then no conversion will be performed, 
If expression returns one result, or node's value is a constant, then no conversion will be performed, 
unless necessary due to different types in expression's result or constant.
unless necessary due to different types in expression's result or constant.


If node contains formatting children, these will be evaluated as a formatting expression, before Expression 
If node contains formatting children, these will be evaluated as a formatting expression, before Expression 
is created, or constant is returned.
is created, or constant is returned.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node that will be used as data source for any expressions within formatting <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataSource</td><td>Node that will be used as data source for any expressions within formatting paramaters of node's value.</td></tr>
  </table>
  </dd>
</dl>
paramaters of node's value.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a single value of type T from the constant or expression given. Returns a single value of type T from the constant or expression given.</p>
<pre class="fragment">If value is an expression, then expression will be evaluated, and result of expression converted to T. 
If value is an expression, then expression will be evaluated, and result of expression converted to T. 
If expression yields multiple results, then the results will be concatenated into a string, in order
If expression yields multiple results, then the results will be concatenated into a string, in order
evaluated, before string is converted to T and returned.
evaluated, before string is converted to T and returned.


If expression returns one result, or node's value is a constant, then no conversion will be performed, 
If expression returns one result, or node's value is a constant, then no conversion will be performed, 
unless necessary due to different types in expression's result or constant.
unless necessary due to different types in expression's result or constant.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node that will be used as data source if first parameter is an Expression.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node that will be used as data source if first parameter is an Expression.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to return if expression or constant yields null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object to convert expression or constant's value into and return back to caller.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates the given node's value, which might be either an expression or a constant. Iterates the given node's value, which might be either an expression or a constant.</p>
<pre class="fragment">If node's value is a constant, then this constant will be converted if necessary to T, before returned.
If node's value is a constant, then this constant will be converted if necessary to T, before returned.


If node's value is an Expression, then this expression will be evaluated, and all results converted
If node's value is an Expression, then this expression will be evaluated, and all results converted
to T, before returned to caller.
to T, before returned to caller.


Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
formatting parameters, these will be evaluated before Expression is evaluated.
formatting parameters, these will be evaluated before Expression is evaluated.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates the given node's value, which might be either an expression or a constant. Iterates the given node's value, which might be either an expression or a constant.</p>
<pre class="fragment">If node's value is a constant, then this constant will be converted if necessary to T, before returned.
If node's value is a constant, then this constant will be converted if necessary to T, before returned.


If node's value is an Expression, then this expression will be evaluated, and all results converted
If node's value is an Expression, then this expression will be evaluated, and all results converted
to T, before returned to caller.
to T, before returned to caller.


Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
formatting parameters, these will be evaluated before Expression is evaluated.
formatting parameters, these will be evaluated before Expression is evaluated.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">node</td><td>Node who's value will be evaluated.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source for any formatting expressions within formatting parameters.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source for any formatting expressions within formatting parameters.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates the given node's value, which might be either an expression or a constant. Iterates the given node's value, which might be either an expression or a constant.</p>
<pre class="fragment">If node's value is a constant, then this constant will be converted if necessary to T, before returned.
If node's value is a constant, then this constant will be converted if necessary to T, before returned.


If node's value is an Expression, then this expression will be evaluated, and all results converted
If node's value is an Expression, then this expression will be evaluated, and all results converted
to T, before returned to caller.
to T, before returned to caller.


Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
Node's value can contain formatting parameters, which will be evaluated if existing. If node contains
formatting parameters, these will be evaluated before Expression is evaluated.
formatting parameters, these will be evaluated before Expression is evaluated.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expressionOrConstant</td><td>expression to run on dataSource, or constant object to iterate.</td></tr>
    <tr><td class="paramname">expressionOrConstant</td><td>expression to run on dataSource, or constant object to iterate.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source if expressionOrConstant given is an Expression.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source if expressionOrConstant given is an Expression.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates the given Expression. Iterates the given Expression.</p>
<pre class="fragment">This expression will be evaluated, on the given dataSource node, and all results converted to T, 
This expression will be evaluated, on the given dataSource node, and all results converted to T, 
before returned to caller.
before returned to caller.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>expression to run on dataSource</td></tr>
    <tr><td class="paramname">expression</td><td>expression to run on dataSource</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source if expressionOrConstant given is an Expression.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node to use as data source if expressionOrConstant given is an Expression.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterateChildren</td><td>If true, then the children nodes of the evaluated node will be iterated, and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
and not the actual node itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
    <tr><td class="paramname">T</td><td>Type of object you wish to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates all matches on Node. Iterates all matches on Node.</p>
<pre class="fragment">Node's value must be an Expression, otherwise an exception will be thrown.
Node's value must be an Expression, otherwise an exception will be thrown.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node being both expression node and data source node.</td></tr>
    <tr><td class="paramname">node</td><td>Node being both expression node and data source node.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates all matches on Node. Iterates all matches on Node.</p>
<pre class="fragment">Node's value must be an Expression, otherwise an exception will be thrown.
Node's value must be an Expression, otherwise an exception will be thrown.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node being both expression node and data source node.</td></tr>
    <tr><td class="paramname">node</td><td>Node being both expression node and data source node.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node for any formatting expressions within node parameter.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node for any formatting expressions within node parameter.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>the next one is only used in [pf.data.select], try to rethink logic of this part, somehow </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>the next one is only used in [pf.data.select], try to rethink logic of this part, somehow </dd></dl>
<p>Returns all matches from expression in node. Returns all matches from expression in node.</p>
<pre class="fragment">Node may contain formatting parameters, which will be evaluated before expression, using formattingSource 
Node may contain formatting parameters, which will be evaluated before expression, using formattingSource 
as start node, for any expressions within formatting parameters, while using dataSource as source for 
as start node, for any expressions within formatting parameters, while using dataSource as source for 
evaluating expression parameters.
evaluating expression parameters.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node being expression node.</td></tr>
    <tr><td class="paramname">node</td><td>Node being expression node.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node.</td></tr>
    <tr><td class="paramname">formattingSource</td><td>Node being data source node for formatting expressions within Expression <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formattingSource</td><td>Node being data source node for formatting expressions within Expression in main node parameter.</td></tr>
  </table>
  </dd>
</dl>
in main node parameter.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Rehink the name of the dataSource parameters in all of these methods, since it is a highly unintuitive name. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Rehink the name of the dataSource parameters in all of these methods, since it is a highly unintuitive name. </dd></dl>
<p>Returns all matches from given Expression. Returns all matches from given Expression.</p>
<pre class="fragment">Will iterate, and return, all matches from the given Expression.
Will iterate, and return, all matches from the given Expression.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression to evaluate.</td></tr>
    <tr><td class="paramname">expression</td><td>Expression to evaluate.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node being data source node.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of the [source], [rel-source], [src] or [re-src] child node. Retrieves the value of the [source], [rel-source], [src] or [re-src] child node.</p>
<pre class="fragment">Converts the result to type T. Returns null if no source exists. Does not care about whether or 
Converts the result to type T. Returns null if no source exists. Does not care about whether or 
not there are multiple values, and will return a List if there are, though
not there are multiple values, and will return a List if there are, though
will attempt to return only one value if it can, such as when there's a list containing only one value.
will attempt to return only one value if it can, such as when there's a list containing only one value.


Will only evaluate the last child node of the given node parameter, expecting its name to be [source], [rel-source],
Will only evaluate the last child node of the given node parameter, expecting its name to be [source], [rel-source],
[src] or [rel-src]. If the last child node of the given node parameter does not match the previous criteria, then
[src] or [rel-src]. If the last child node of the given node parameter does not match the previous criteria, then
there will be no valid source, and method will return null.
there will be no valid source, and method will return null.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child node.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child node.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>refactor these next buggers, they're too complex </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>refactor these next buggers, they're too complex </dd></dl>
<p>Retrieves the value of the [source], [rel-source], [src] or [re-src] child node. Retrieves the value of the [source], [rel-source], [src] or [re-src] child node.</p>
<pre class="fragment">Converts the result to type T. Returns null if no source exists. Does not care about whether or 
Converts the result to type T. Returns null if no source exists. Does not care about whether or 
not there are multiple values, and will return a List if there are, though
not there are multiple values, and will return a List if there are, though
will attempt to return only one value if it can, such as when there's a list containing only one value.
will attempt to return only one value if it can, such as when there's a list containing only one value.


Will only evaluate the last child node of the given node parameter, expecting its name to be [source], [rel-source],
Will only evaluate the last child node of the given node parameter, expecting its name to be [source], [rel-source],
[src] or [rel-src]. If the last child node of the given node parameter does not match the previous criteria, then
[src] or [rel-src]. If the last child node of the given node parameter does not match the previous criteria, then
there will be no valid source, and method will return null.
there will be no valid source, and method will return null.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child node.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child node.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node used as data source for expressions within the node parameter.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node used as data source for expressions within the node parameter.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of [source], [rel-source], [src] or [rel-src] child node Retrieves the value of [source], [rel-source], [src] or [rel-src] child node</p>
<pre class="fragment">Will force one single return value, somehow. Returns null if no source exists. Used in among other things [set].
Will force one single return value, somehow. Returns null if no source exists. Used in among other things [set].
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of [source], [rel-source], [src] or [rel-src] child node. Retrieves the value of [source], [rel-source], [src] or [rel-src] child node.</p>
<pre class="fragment">Will force one single return value, somehow. Returns null if no source exists. Used in among other things [set].
Will force one single return value, somehow. Returns null if no source exists. Used in among other things [set].
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node which will be used as data source node if node's parameter's value is an Expression.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node which will be used as data source node if node's parameter's value is an Expression.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of [source], [rel-source], [src] or [rel-src] child node. Retrieves the value of [source], [rel-source], [src] or [rel-src] child node.</p>
<pre class="fragment">Might return multiple values. Returns null if no source exists. Used in among other things [append].
Might return multiple values. Returns null if no source exists. Used in among other things [append].
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<p>Retrieves the value of [source], [rel-source], [src] or [rel-src] child node. Retrieves the value of [source], [rel-source], [src] or [rel-src] child node.</p>
<pre class="fragment">Might return multiple values. Returns null if no source exists. Used in among other things [append].
Might return multiple values. Returns null if no source exists. Used in among other things [append].
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">node</td><td>Node where [source], [rel-source], [rel-src] or [src] is expected to be a child.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node used as dataSource for formatting expressions within node parameter.</td></tr>
    <tr><td class="paramname">dataSource</td><td>Node used as dataSource for formatting expressions within node parameter.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>try to refactor, too complex </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>try to refactor, too complex </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <p id="copyright-notice">Phosphorus.Five is Free and Open Source Software. Phosphorus is licensed under the terms of the <a href="http://opensource.org/licenses/MIT">MIT license</a>. Phosphorus is a <a href="http://magixilluminate.com">Magix Illuminate</a> Production</p>
</body>
</html>
