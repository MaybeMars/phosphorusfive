<!DOCTYPE html>
<html>
<head>
<title>Phosphorus.Five - Enabling Agile Development - Package iterators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top">
<div id="titlearea">
  <a class="logo" title="Phosphorus.Five project main website" href="http://magixilluminate.com">
  <img alt="Magix Illuminate" src="magix-logo-big.png"/>
  </a>
  <h1 id="projectname">Phosphorus.Five</h1>
  <p id="projectbrief">Enabling Agile Development</p>
  <a id="download-tar" title="download tarball" href="https://github.com/polterguy/phosphorus-five/tarball/master">&nbsp;</a>
  <a id="download-zip" title="downlad zipball" href="https://github.com/polterguy/phosphorus-five/zipball/master">&nbsp;</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Package iterators</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a169c4377c26f2dfc226921f7e5852828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterators.html#a169c4377c26f2dfc226921f7e5852828">[instance initializer]</a></td></tr>
<tr class="separator:a169c4377c26f2dfc226921f7e5852828"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for all pf.lambda Expression Iterators. Main namespace for all pf.lambda Expression Iterators.</p>
<pre class="fragment">A pf.lambda Expression Iterator is an sub-part of a pf.lambda expression, which informs the expression engine what types
A pf.lambda Expression Iterator is an sub-part of a pf.lambda expression, which informs the expression engine what types
of criteria the nodes from the previous iterator, if any, the nodes should match, in order to become a part of the result
of criteria the nodes from the previous iterator, if any, the nodes should match, in order to become a part of the result
for the next iterator.
for the next iterator.


An iterator starts with a slash (/), and can optionally end with a slash. The iterator's content, can optionally be put
An iterator starts with a slash (/), and can optionally end with a slash. The iterator's content, can optionally be put
inside of double-quotes ("), if you have complex characters, that are normally considered control characters in the expression
inside of double-quotes ("), if you have complex characters, that are normally considered control characters in the expression
engine.
engine.


You can also compose multi-line string iterators, by putting your iterator's content inside of @"xxx" as a multi-line string literal.
You can also compose multi-line string iterators, by putting your iterator's content inside of @"xxx" as a multi-line string literal.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a169c4377c26f2dfc226921f7e5852828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterators.[instance initializer] </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator class, wrapping one iterator, for pf.lambda expressions. Iterator class, wrapping one iterator, for pf.lambda expressions.</p>
<pre class="fragment">Iterators are executed as a chain, encapsulated within a &lt;see cref="phosphorus.expressions.Logical" /&gt; object, which again 
Iterators are executed as a chain, encapsulated within a &lt;see cref="phosphorus.expressions.Logical" /&gt; object, which again 
is a child of &lt;see cref="phosphorus.expressions.iterators.IteratorGroup" /&gt;, which again is an iterator in itself.
is a child of &lt;see cref="phosphorus.expressions.iterators.IteratorGroup" /&gt;, which again is an iterator in itself.


When iterators are evaluated, they're evaluated in a left-associative manner, where the last iterator is
When iterators are evaluated, they're evaluated in a left-associative manner, where the last iterator is
evaluated last, and evaluated as a result of its previous iterator's Left property.
evaluated last, and evaluated as a result of its previous iterator's Left property.


The root iterator of all expressions, is normally an iterator containing a single &lt;see cref="phosphorus.core.Node"/&gt; instance,
The root iterator of all expressions, is normally an iterator containing a single &lt;see cref="phosphorus.core.Node"/&gt; instance,
from which iteration begins.
from which iteration begins.


An example of an Expression containing two iterators are given here for reference purposes;
An example of an Expression containing two iterators are given here for reference purposes;


&lt;pre&gt;@/../*?node&lt;/pre&gt;
&lt;pre&gt;@/../*?node&lt;/pre&gt;


The above Expression has one IteratorRoot iterator, and one IteratorChildren iterator, and has the type declaration
The above Expression has one IteratorRoot iterator, and one IteratorChildren iterator, and has the type declaration
leading to extracting the 'value' of its resulting nodes. Effectively leading to extracting all Value properties of
leading to extracting the 'value' of its resulting nodes. Effectively leading to extracting all Value properties of
all children nodes of the root node of your expression.
all children nodes of the root node of your expression.
</pre> <p>Gets or sets the left or "previous iterator". Gets or sets the left or "previous iterator".</p>
<pre class="fragment">The left iterator is the "previous iterator" in the chain of iterators for your expressions.
The left iterator is the "previous iterator" in the chain of iterators for your expressions.
</pre> <p>Its previous iterator in its chain of iterators.</p>
<p>Its previous iterator in its chain of iterators.</p>
<p>Evaluates the iterator. Evaluates the iterator.</p>
<pre class="fragment">Will evaluate your expression, and return a list of nodes, matching your Expression.
Will evaluate your expression, and return a list of nodes, matching your Expression.
</pre> <p>The evaluated result, returning a list of phosphorus.core.Nodes.</p>
<p>The evaluated result, returning a list of phosphorus.core.Nodes.</p>
<p>Returns true if this is a "reference expression". Returns true if this is a "reference expression".</p>
<pre class="fragment">A reference expression is normally defined by having two consecutive @ characters in its beginning. This
A reference expression is normally defined by having two consecutive @ characters in its beginning. This
signals to the Expression engine that the expression is not necessarily to be directly evaluated, but that it
signals to the Expression engine that the expression is not necessarily to be directly evaluated, but that it
might point to another expression, and if it does, then that Expression will be evaluated, and the results of
might point to another expression, and if it does, then that Expression will be evaluated, and the results of
that evaluation process returned back to caller.
that evaluation process returned back to caller.
</pre> <p>true if this is a reference expression, otherwise false.</p>
<p>true if this is a reference expression, otherwise false.</p>
<p>Returns all children of previous iterator. Returns all children of previous iterator.</p>
<pre class="fragment">Will return all Children nodes of the results of the previous Iterator.
Will return all Children nodes of the results of the previous Iterator.


Example;
Example;
&lt;pre&gt;/*&lt;/pre&gt;
&lt;pre&gt;/*&lt;/pre&gt;
</pre> <p>Returns all nodes, and descendants, of previous iterator. Returns all nodes, and descendants, of previous iterator.</p>
<pre class="fragment">This Iterator will return ALL nodes from its previous result, including all children, children's children, and 
This Iterator will return ALL nodes from its previous result, including all children, children's children, and 
so on, from its previous iterator.
so on, from its previous iterator.


Warning! This might be a very, very large result set for large node trees!
Warning! This might be a very, very large result set for large node trees!


Example;
Example;
&lt;pre&gt;/**&lt;/pre&gt;
&lt;pre&gt;/**&lt;/pre&gt;
</pre> <p>Special Iterator for grouping iterators. Special Iterator for grouping iterators.</p>
<pre class="fragment">An IteratorGroup will either iterate on the result of its parent group, or a single node. By grouping iterators, 
An IteratorGroup will either iterate on the result of its parent group, or a single node. By grouping iterators, 
you can have multiple iterators grouped together, working with the evaluated results, of its parent group iterator.
you can have multiple iterators grouped together, working with the evaluated results, of its parent group iterator.


Normally a "group" is declared by having a sub-expression declared inside of parenthesis "()", where the sub-expression(s)
Normally a "group" is declared by having a sub-expression declared inside of parenthesis "()", where the sub-expression(s)
will be evaluated using the outer Expression as its source nodes.
will be evaluated using the outer Expression as its source nodes.


Example;
Example;
&lt;pre&gt;(/some-iterator)&lt;/pre&gt;
&lt;pre&gt;(/some-iterator)&lt;/pre&gt;
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorGroup class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorGroup class.</p>
<pre class="fragment">This constructor is for creating the "outer most iterator", or "root iterator", of your hyperlisp expressions, 
This constructor is for creating the "outer most iterator", or "root iterator", of your hyperlisp expressions, 
and is normally exclusively used as the main root iterator for your entire Expression.
and is normally exclusively used as the main root iterator for your entire Expression.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to start iteration from.</td></tr>
    <tr><td class="paramname">node</td><td>Node to start iteration from.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorGroup class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorGroup class.</p>
<pre class="fragment">This constructor is for creating sub-expressions, where each sub-expression is being evaluated from its parent
This constructor is for creating sub-expressions, where each sub-expression is being evaluated from its parent
group's Expression.
group's Expression.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent iterator group.</td></tr>
    <tr><td class="paramname">parent</td><td>Parent iterator group.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the parent group. Returns the parent group.</p>
<pre class="fragment">The parent group, is the "outer-expression" of your group, if any. The root group, has no parent group.
The parent group, is the "outer-expression" of your group, if any. The root group, has no parent group.
</pre> <p>the parent group</p>
<p>the parent group</p>
<p>Gets the last iterator in the group. Gets the last iterator in the group.</p>
<pre class="fragment">This is where you append a new Iterator, when constructing your chain of iterators.
This is where you append a new Iterator, when constructing your chain of iterators.
</pre> <p>the last iterator</p>
<p>the last iterator</p>
<p>Returns true if this is a "reference expression". Returns true if this is a "reference expression".</p>
<pre class="fragment">A reference Expression is normally delcared by starting your expression with two "@@" characters. This
A reference Expression is normally delcared by starting your expression with two "@@" characters. This
signals to the expression engine, that instead of directly evaluating that expression, evaluate what the expression
signals to the expression engine, that instead of directly evaluating that expression, evaluate what the expression
refers to. This allows you to pass around expressions as arguments to Active Events, where your Active Events evaluates
refers to. This allows you to pass around expressions as arguments to Active Events, where your Active Events evaluates
the expressions you pass into them, instead of evaluating them directly.
the expressions you pass into them, instead of evaluating them directly.


Think of a reference expression as a "pointer" from C/C++, or a "reference object" in C#.
Think of a reference expression as a "pointer" from C/C++, or a "reference object" in C#.
</pre> <p>true if this is a reference expression, otherwise false</p>
<p>true if this is a reference expression, otherwise false</p>
<p>Adds a Logical to the list of logicals in the group. Adds a Logical to the list of logicals in the group.</p>
<pre class="fragment">Logicals are what allows you to perform Boolean Algebra on your expressions, and are normally defined in your 
Logicals are what allows you to perform Boolean Algebra on your expressions, and are normally defined in your 
expressions using either of these characters; &amp;, |, ^ or !
expressions using either of these characters; &amp;, |, ^ or !


! is your NOT operator, and means that it should NOT return whatever is returned as a result of your right-hand-side sub-expression.
! is your NOT operator, and means that it should NOT return whatever is returned as a result of your right-hand-side sub-expression.


| is your OR operator, and signifies that your expression should add together the results of your right-hand-side expression, 
| is your OR operator, and signifies that your expression should add together the results of your right-hand-side expression, 
with whatever is at your left-hand-side as a combined result.
with whatever is at your left-hand-side as a combined result.


&amp; is your AND operator, and basically means that in order to be a part of the combined results, the nodes must match both the 
&amp; is your AND operator, and basically means that in order to be a part of the combined results, the nodes must match both the 
left-hand-side, and the right-hand-side sub-expression.
left-hand-side, and the right-hand-side sub-expression.


^ is your XOR operator, and basically means that it should combine together the results of both your left-hand-side, with your
^ is your XOR operator, and basically means that it should combine together the results of both your left-hand-side, with your
right-hand-side, but only if it matches only ONE of your sides, and not if it matches neither sides or both sides.
right-hand-side, but only if it matches only ONE of your sides, and not if it matches neither sides or both sides.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logical</td><td>logical</td></tr>
    <tr><td class="paramname">logical</td><td>logical</td></tr>
  </table>
  </dd>
</dl>
<p>Appends a new iterator to the last phosphorus.expressions.Logical in the group. Appends a new iterator to the last phosphorus.expressions.Logical in the group.</p>
<pre class="fragment">Appends a new Iterator at the end of your current iterator chain for evaluation of your Expression.
Appends a new Iterator at the end of your current iterator chain for evaluation of your Expression.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Iterator to append.</td></tr>
    <tr><td class="paramname">iterator</td><td>Iterator to append.</td></tr>
  </table>
  </dd>
</dl>
<p>Root iterators for nested IteratorGroup iterators. Root iterators for nested IteratorGroup iterators.</p>
<pre class="fragment">Helper Iterator to declare a new IteratorGroup. Internally used when a new group, or sub-expression is declared, 
Helper Iterator to declare a new IteratorGroup. Internally used when a new group, or sub-expression is declared, 
using parenthesis.
using parenthesis.


This iterator is never directly consumed in your code, but automatically created for you when you create an IteratorGroup
This iterator is never directly consumed in your code, but automatically created for you when you create an IteratorGroup
Iterator.
Iterator.
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorLeftParent class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorLeftParent class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leftParent</td><td>The last iterator of the parent group iterator.</td></tr>
    <tr><td class="paramname">leftParent</td><td>The last iterator of the parent group iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all nodes matching the given modulo. Returns all nodes matching the given modulo.</p>
<pre class="fragment">Will return all n'th node from previous Iterator result, where "n" is defined through a modulo iterator, for instance; /%2
Will return all n'th node from previous Iterator result, where "n" is defined through a modulo iterator, for instance; /%2
to return all "even nodes" from previous iterator.
to return all "even nodes" from previous iterator.


Example;
Example;
&lt;pre&gt;/%2&lt;/pre&gt;
&lt;pre&gt;/%2&lt;/pre&gt;
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorModulo class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorModulo class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modulo</td><td>modulo</td></tr>
    <tr><td class="paramname">modulo</td><td>modulo</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all nodes with the specified name. Returns all nodes with the specified name.</p>
<pre class="fragment">Will filter away all nodes from previous Iterator that does not match the name given through this iterator. If 
Will filter away all nodes from previous Iterator that does not match the name given through this iterator. If 
name given starts with a back-slash, then the first back-slash will be removed. This allows you to use named iterators,
name given starts with a back-slash, then the first back-slash will be removed. This allows you to use named iterators,
where the Expression engine would normally choose another type of iterator, due to that your name fulfills the criteria for
where the Expression engine would normally choose another type of iterator, due to that your name fulfills the criteria for
being a different type of iterator.
being a different type of iterator.


For instance, to return a node who's name is "555", instead of the 555th child node of previous results, you can use; /\555
For instance, to return a node who's name is "555", instead of the 555th child node of previous results, you can use; /\555
as the value of your iterator.
as the value of your iterator.


Example;
Example;
&lt;pre&gt;/some-name&lt;/pre&gt;
&lt;pre&gt;/some-name&lt;/pre&gt;


This iterator is the default iterator being used by the Expression engine, unless it can find a better match for another type
This iterator is the default iterator being used by the Expression engine, unless it can find a better match for another type
of iterator. Meaning, if your iterator doesn't match any of the other specialized iterators, then the engine defaults to
of iterator. Meaning, if your iterator doesn't match any of the other specialized iterators, then the engine defaults to
treating your iterator as an iterator of this type.
treating your iterator as an iterator of this type.
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorNamed class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorNamed class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to match</td></tr>
    <tr><td class="paramname">name</td><td>name to match</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the first ancestor node matching the specified name. Returns the first ancestor node matching the specified name.</p>
<pre class="fragment">Will traverse the node hierarchy upwards from its current results, and return the first ancestor node
Will traverse the node hierarchy upwards from its current results, and return the first ancestor node
who's name matches the value after the ".." parts of the Iterator.
who's name matches the value after the ".." parts of the Iterator.


Example;
Example;
&lt;pre&gt;/..foo&lt;/pre&gt;
&lt;pre&gt;/..foo&lt;/pre&gt;
</pre> <p>initializes a new instance of the phosphorus.expressions.iterators.IteratorNamedAncestor class initializes a new instance of the phosphorus.expressions.iterators.IteratorNamedAncestor class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to look for</td></tr>
    <tr><td class="paramname">name</td><td>name to look for</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all nodes who's names matches the specified regular expression. Returns all nodes who's names matches the specified regular expression.</p>
<pre class="fragment">Will return all nodes who's name matches the given regular expression. Notice that when you use this Iterator, 
Will return all nodes who's name matches the given regular expression. Notice that when you use this Iterator, 
the entire iterator's value must be put into either double quote ("), to signify a single line string literal, 
the entire iterator's value must be put into either double quote ("), to signify a single line string literal, 
or created using multi-line strings, since the iterator is recognized as starting and ending with a "slash".
or created using multi-line strings, since the iterator is recognized as starting and ending with a "slash".


Example; &lt;pre&gt;/"/foo/"&lt;/pre&gt;
Example; &lt;pre&gt;/"/foo/"&lt;/pre&gt;


Will match all nodes who's name contains the text "foo".
Will match all nodes who's name contains the text "foo".


You can optionally pass in arguments to the regular expression engine, after the last slash (/) of your iterator's content.
You can optionally pass in arguments to the regular expression engine, after the last slash (/) of your iterator's content.
These parameters can be either of;
These parameters can be either of;


&lt;strong&gt;d&lt;/strong&gt; - Only return distinct names. If two nodes have the same names, only return the first node matching.
&lt;strong&gt;d&lt;/strong&gt; - Only return distinct names. If two nodes have the same names, only return the first node matching.


&lt;strong&gt;i&lt;/strong&gt; - Ignore case when doing the comparison.
&lt;strong&gt;i&lt;/strong&gt; - Ignore case when doing the comparison.


&lt;strong&gt;m&lt;/strong&gt; - Multiline regex comparison.
&lt;strong&gt;m&lt;/strong&gt; - Multiline regex comparison.


&lt;strong&gt;c&lt;/strong&gt; - Compile the regular expression to optimize execution for later usage of the same regular expression.
&lt;strong&gt;c&lt;/strong&gt; - Compile the regular expression to optimize execution for later usage of the same regular expression.


&lt;strong&gt;e&lt;/strong&gt; - Use ECMA script regular expression type.
&lt;strong&gt;e&lt;/strong&gt; - Use ECMA script regular expression type.


&lt;strong&gt;w&lt;/strong&gt; - Ignore white space patterns.
&lt;strong&gt;w&lt;/strong&gt; - Ignore white space patterns.


&lt;strong&gt;r&lt;/strong&gt; - Execute the regular expression from right to left.
&lt;strong&gt;r&lt;/strong&gt; - Execute the regular expression from right to left.


&lt;strong&gt;s&lt;/strong&gt; - Single line regular expression mode.
&lt;strong&gt;s&lt;/strong&gt; - Single line regular expression mode.


Here's an example of how to use ECMA script type of regular expressions, compile the regular expression, while only 
Here's an example of how to use ECMA script type of regular expressions, compile the regular expression, while only 
returning distinct names, to return any node's who's names contains the text "bar";
returning distinct names, to return any node's who's names contains the text "bar";


&lt;pre&gt;/"/bar/edc"&lt;/pre&gt;
&lt;pre&gt;/"/bar/edc"&lt;/pre&gt;
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorNamed class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorNamed class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>Regular expression</td></tr>
    <tr><td class="paramname">regex</td><td>Regular expression</td></tr>
    <tr><td class="paramname">expression</td><td>pf.lambda expression</td></tr>
    <tr><td class="paramname">expression</td><td>pf.lambda expression</td></tr>
    <tr><td class="paramname">node</td><td>node</td></tr>
    <tr><td class="paramname">node</td><td>node</td></tr>
    <tr><td class="paramname">context</td><td>application context</td></tr>
    <tr><td class="paramname">context</td><td>application context</td></tr>
  </table>
  </dd>
</dl>
<p>phosphorus.core.Node Iterator. phosphorus.core.Node Iterator.</p>
<pre class="fragment">This Iterator is never used directly by your code, but implicitly given through your expressions, and normally
This Iterator is never used directly by your code, but implicitly given through your expressions, and normally
points to the "identity Node", which is the &lt;see cref="phosphorus.core.Node"&gt;Node&lt;/see&gt; where your Expression is
points to the "identity Node", which is the &lt;see cref="phosphorus.core.Node"&gt;Node&lt;/see&gt; where your Expression is
declared.
declared.
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorNode class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorNode class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to start iterating upon</td></tr>
    <tr><td class="paramname">node</td><td>the node to start iterating upon</td></tr>
  </table>
  </dd>
</dl>
<p>Iterator for returning the n'th children of previous iterator result. Iterator for returning the n'th children of previous iterator result.</p>
<pre class="fragment">Will return the n'th children node of the nodes in the previous iterator's result.
Will return the n'th children node of the nodes in the previous iterator's result.


Example, will return the 3rd child node from previous result-set;
Example, will return the 3rd child node from previous result-set;
&lt;pre&gt;/2&lt;/pre&gt;
&lt;pre&gt;/2&lt;/pre&gt;
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorNumbered class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorNumbered class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">number</td><td>The n'th child to return, if it exists, from previous result-set.</td></tr>
    <tr><td class="paramname">number</td><td>The n'th child to return, if it exists, from previous result-set.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all parent phosphorus.core.Nodes of previous iterator result. Returns all parent phosphorus.core.Nodes of previous iterator result.</p>
<pre class="fragment">Example;
Example;
&lt;pre&gt;/.&lt;/pre&gt;
&lt;pre&gt;/.&lt;/pre&gt;
</pre> <p>Returns all nodes within the specified range. Returns all nodes within the specified range.</p>
<pre class="fragment">Returns all nodes within the given range from previous result-set.
Returns all nodes within the given range from previous result-set.


Example, will return the second and third node from previous result-set;
Example, will return the second and third node from previous result-set;
&lt;pre&gt;/[1,3]&lt;/pre&gt;
&lt;pre&gt;/[1,3]&lt;/pre&gt;
</pre> <p>initializes a new instance of the phosphorus.expressions.iterators.IteratorRange class initializes a new instance of the phosphorus.expressions.iterators.IteratorRange class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>start position, from</td></tr>
    <tr><td class="paramname">from</td><td>start position, from</td></tr>
    <tr><td class="paramname">to</td><td>end position, to</td></tr>
    <tr><td class="paramname">to</td><td>end position, to</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all nodes found through value of previous node's matched converted to path or node. Returns all nodes found through value of previous node's matched converted to path or node.</p>
<pre class="fragment">Example;
Example;
&lt;pre&gt;/#&lt;/pre&gt;
&lt;pre&gt;/#&lt;/pre&gt;
</pre> <p>Base class for all regular expression iterators. Base class for all regular expression iterators.</p>
<pre class="fragment">Not to be consumed directly by your code, but indirectly accessible through IteratorNamedRegex and IteratorValuedRegex.
Not to be consumed directly by your code, but indirectly accessible through IteratorNamedRegex and IteratorValuedRegex.
Contains helper methods for previously mentioned iterators, such as extracting regex options, etc.
Contains helper methods for previously mentioned iterators, such as extracting regex options, etc.
</pre> <p>Returns regular expression engine options for regex iterator. Returns regular expression engine options for regex iterator. </p>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Regex options.</p>
<p class="enddd">Regex options.</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optionsString</td><td>String containing textual representation of all options.</td></tr>
    <tr><td class="paramname">optionsString</td><td>String containing textual representation of all options.</td></tr>
    <tr><td class="paramname">expression</td><td>Necessary in case an exception needs to be raised, to provide contextual information.</td></tr>
    <tr><td class="paramname">expression</td><td>Necessary in case an exception needs to be raised, to provide contextual information.</td></tr>
    <tr><td class="paramname">node</td><td>Necessary to provide contextual information in case an exception occurs.</td></tr>
    <tr><td class="paramname">node</td><td>Necessary to provide contextual information in case an exception occurs.</td></tr>
    <tr><td class="paramname">context</td><td>Application context</td></tr>
    <tr><td class="paramname">context</td><td>Application context</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the "root" phosphorus.core.Node of your tree-structure. Returns the "root" phosphorus.core.Node of your tree-structure.</p>
<pre class="fragment">Will return the root node of your tree.
Will return the root node of your tree.


Example;
Example;
&lt;pre&gt;/..&lt;/pre&gt;
&lt;pre&gt;/..&lt;/pre&gt;
</pre> <p>Returns the "previous node". Returns the "previous node".</p>
<pre class="fragment">To understand how this method works, see the documentation for &lt;see cref="phosphorus.core.PreviousNode"/&gt;, since
To understand how this method works, see the documentation for &lt;see cref="phosphorus.core.PreviousNode"/&gt;, since
it basically is an implementation of an Iterator doing exactly what that method does.
it basically is an implementation of an Iterator doing exactly what that method does.


Example;
Example;
&lt;pre&gt;/&amp;lt;&lt;/pre&gt;
&lt;pre&gt;/&amp;lt;&lt;/pre&gt;
</pre> <p>Returns the "next node". Returns the "next node".</p>
<pre class="fragment">To understand how this method works, see the documentation for &lt;see cref="phosphorus.core.NextNode"/&gt;, since
To understand how this method works, see the documentation for &lt;see cref="phosphorus.core.NextNode"/&gt;, since
it basically is an implementation of an Iterator doing exactly what that method does.
it basically is an implementation of an Iterator doing exactly what that method does.


Example;
Example;
&lt;pre&gt;/&amp;gt;&lt;/pre&gt;
&lt;pre&gt;/&amp;gt;&lt;/pre&gt;
</pre> <p>Returns an offset sibling node from previous result-set. Returns an offset sibling node from previous result-set.</p>
<pre class="fragment">Can start with either "+" or "-", depending upon whether or not you'd like to retrieve a "younger sibling"
Can start with either "+" or "-", depending upon whether or not you'd like to retrieve a "younger sibling"
or an "older sibling" from the previous result-set. Next comes an integer value, defining how many siblings
or an "older sibling" from the previous result-set. Next comes an integer value, defining how many siblings
you wish to "jump".
you wish to "jump".


Example, that returns the sibling which is "two generations older" than your current result-set node's;
Example, that returns the sibling which is "two generations older" than your current result-set node's;
&lt;pre&gt;/+2&lt;/pre&gt;
&lt;pre&gt;/+2&lt;/pre&gt;
</pre> <p>initializes a new instance of the phosphorus.expressions.iterators.IteratorSibling class initializes a new instance of the phosphorus.expressions.iterators.IteratorSibling class </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>offset siblings from current nodes</td></tr>
    <tr><td class="paramname">offset</td><td>offset siblings from current nodes</td></tr>
  </table>
  </dd>
</dl>
<p>Returns all nodes with the specified value. Returns all nodes with the specified value.</p>
<pre class="fragment">This Iterator can optionally be given a "type declaration", from which a type, represented by the string in
This Iterator can optionally be given a "type declaration", from which a type, represented by the string in
its value will be created from. But the type declaration is optional, and defaults to 'string'.
its value will be created from. But the type declaration is optional, and defaults to 'string'.


Example that returns all nodes who's value equals the string 'foo';
Example that returns all nodes who's value equals the string 'foo';


&lt;pre&gt;/=foo&lt;/pre&gt;
&lt;pre&gt;/=foo&lt;/pre&gt;


Example that returns all nodes who's value equals the integer value of '5';
Example that returns all nodes who's value equals the integer value of '5';


&lt;pre&gt;/=:int:5&lt;/pre&gt;
&lt;pre&gt;/=:int:5&lt;/pre&gt;
</pre> <p>Returns all nodes having a value matching the given regular expression. Returns all nodes having a value matching the given regular expression.</p>
<pre class="fragment">Will return all nodes who's value matches the given regular expression. Notice that when you use this Iterator, 
Will return all nodes who's value matches the given regular expression. Notice that when you use this Iterator, 
the entire iterator's value must be put into either double quote ("), to signify a single line string literal, 
the entire iterator's value must be put into either double quote ("), to signify a single line string literal, 
or created using multi-line strings, since the iterator is having "slash" (/) as part of its control mechanisms.
or created using multi-line strings, since the iterator is having "slash" (/) as part of its control mechanisms.


Example; &lt;pre&gt;/"=/foo/"&lt;/pre&gt;
Example; &lt;pre&gt;/"=/foo/"&lt;/pre&gt;


Will match all nodes who's value contains the text "foo".
Will match all nodes who's value contains the text "foo".


You can optionally pass in arguments to the regular expression engine, after the last slash (/) of your iterator's content.
You can optionally pass in arguments to the regular expression engine, after the last slash (/) of your iterator's content.
These parameters can be either of;
These parameters can be either of;


&lt;strong&gt;d&lt;/strong&gt; - Only return distinct names. If two nodes have the same names, only return the first node matching.
&lt;strong&gt;d&lt;/strong&gt; - Only return distinct names. If two nodes have the same names, only return the first node matching.


&lt;strong&gt;i&lt;/strong&gt; - Ignore case when doing the comparison.
&lt;strong&gt;i&lt;/strong&gt; - Ignore case when doing the comparison.


&lt;strong&gt;m&lt;/strong&gt; - Multiline regex comparison.
&lt;strong&gt;m&lt;/strong&gt; - Multiline regex comparison.


&lt;strong&gt;c&lt;/strong&gt; - Compile the regular expression to optimize execution for later usage of the same regular expression.
&lt;strong&gt;c&lt;/strong&gt; - Compile the regular expression to optimize execution for later usage of the same regular expression.


&lt;strong&gt;e&lt;/strong&gt; - Use ECMA script regular expression type.
&lt;strong&gt;e&lt;/strong&gt; - Use ECMA script regular expression type.


&lt;strong&gt;w&lt;/strong&gt; - Ignore white space patterns.
&lt;strong&gt;w&lt;/strong&gt; - Ignore white space patterns.


&lt;strong&gt;r&lt;/strong&gt; - Execute the regular expression from right to left.
&lt;strong&gt;r&lt;/strong&gt; - Execute the regular expression from right to left.


&lt;strong&gt;s&lt;/strong&gt; - Single line regular expression mode.
&lt;strong&gt;s&lt;/strong&gt; - Single line regular expression mode.


Here's an example of how to use ECMA script type of regular expressions, compile the regular expression, while only 
Here's an example of how to use ECMA script type of regular expressions, compile the regular expression, while only 
returning distinct values, to return any node's who's values contains the text "bar";
returning distinct values, to return any node's who's values contains the text "bar";


&lt;pre&gt;/"=/bar/edc"&lt;/pre&gt;
&lt;pre&gt;/"=/bar/edc"&lt;/pre&gt;
</pre> <p>Initializes a new instance of the phosphorus.expressions.iterators.IteratorValuedRegex class. Initializes a new instance of the phosphorus.expressions.iterators.IteratorValuedRegex class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>Regular expression to match.</td></tr>
    <tr><td class="paramname">regex</td><td>Regular expression to match.</td></tr>
    <tr><td class="paramname">expression</td><td>Expression containing the Iterator. Necessary to provide contextual information in case an <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>Expression containing the Iterator. Necessary to provide contextual information in case an exception occurs.</td></tr>
  </table>
  </dd>
</dl>
exception occurs.</td></tr>
    <tr><td class="paramname">node</td><td>The node containing the Expression. Also necessary to provide contextual information in case an exception <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node containing the Expression. Also necessary to provide contextual information in case an exception occurs.</td></tr>
  </table>
  </dd>
</dl>
occurs.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
    <tr><td class="paramname">context</td><td>Application context.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <p id="copyright-notice">Phosphorus.Five is Free and Open Source Software. Phosphorus is licensed under the terms of the <a href="http://opensource.org/licenses/MIT">MIT license</a>. Phosphorus is a <a href="http://magixilluminate.com">Magix Illuminate</a> Production</p>
</body>
</html>
